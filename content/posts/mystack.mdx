---
title: Comprehensive MDX Demo
description: This post showcases various MDX elements and custom components cases various MDX elements and custom componentscases various MDX elements and custom components
date: 2023-06-15
tags: [mdx, react, nextjs]
---
# Creating a Dynamic Blog with MDX in Next.js

## Introduction

In this post, we'll explore how to create a dynamic blog using MDX files in a Next.js application. We'll break down a `[slug].tsx` page component that renders MDX content, and explain how to set up a folder structure for your blog posts.

## The Folder Structure

First, let's set up our folder structure. Create a `content/posts` directory in your project root. This is where you'll store your MDX files:

```
your-project/
├── content/
│   └── posts/
│       ├── first-post.mdx
│       ├── second-post.mdx
│       └── ...
└── app/
    └── blog/
        └── [slug]/
            └── page.tsx
```

## The [slug].tsx Page Component

Now, let's break down the `[slug].tsx` page component:

```tsx
import { useMDXComponents } from "@/components/mdx-content";
import TableOfContents from "@/components/toc";
import { calculateReadingTime } from "@/utils/reading-time";
import fs from "fs";
import matter from "gray-matter";
import { Dot } from "lucide-react";
import { MDXRemote } from "next-mdx-remote/rsc";
import path from "path";
import { DetailedHTMLProps, HTMLAttributes } from "react";
import rehypePrism from "rehype-prism-plus";

// ... (rest of the code)
```

### Imports

We start by importing necessary dependencies and components:

- `useMDXComponents`: A custom hook to get MDX components.
- `TableOfContents`: A component to display the table of contents.
- `calculateReadingTime`: A utility function to estimate reading time.
- `fs` and `path`: Node.js modules for file system operations.
- `matter`: A library to parse front matter from markdown files.
- `MDXRemote`: A component from `next-mdx-remote` to render MDX content.
- `rehypePrism`: A plugin for syntax highlighting.

### Static Params Generation

```tsx
export async function generateStaticParams() {
  const postsDirectory = path.join(process.cwd(), "content/posts");
  const fileNames = fs.readdirSync(postsDirectory);

  return fileNames.map((fileName) => ({
    slug: fileName.replace(/\.mdx$/, ""),
  }));
}
```

This function generates the static paths for all blog posts. It reads the `content/posts` directory and creates a slug for each MDX file.

### The BlogPost Component

```tsx
const BlogPost = ({ params }: BlogPostProps) => {
  const postsDirectory = path.join(process.cwd(), "content/posts");
  const fullPath = path.join(postsDirectory, `${params.slug}.mdx`);
  const fileContents = fs.readFileSync(fullPath, "utf8");
  const { content, data } = matter(fileContents);
  const frontmatter = data as Frontmatter;
  const readingTime = calculateReadingTime(content);

  // ... (rest of the component)
```

The `BlogPost` component is responsible for rendering a single blog post. It:

1. Finds the correct MDX file based on the slug.
2. Reads the file contents.
3. Parses the frontmatter and content using `gray-matter`.
4. Calculates the reading time.

### Custom MDX Components

```tsx
const mdxComponents = useMDXComponents({});

const components = {
  ...mdxComponents,
  h2: ({
    children,
    ...props
  }: DetailedHTMLProps<
    HTMLAttributes<HTMLHeadingElement>,
    HTMLHeadingElement
  >) => {
    const id = children?.toString().toLowerCase().replace(/\s+/g, "-");
    return (
      <h2 id={id} {...props}>
        {children}
      </h2>
    );
  },
};
```

Here, we set up custom MDX components. We're adding an `id` to `h2` elements for linking purposes in the table of contents.

### Rendering the Blog Post

```tsx
return (
  <div className="w-full relative">
    <div className="max-w-3xl mx-auto mt-20 px-4">
      <span className="flex items-center gap-2 text-gray-500 text-sm">
        <p>{frontmatter.date?.toDateString()}</p>
        <Dot />
        <p className="">{readingTime} min read</p>
      </span>

      <div className="flex flex-col md:flex-row gap-8 mt-10">
        <aside className="fixed top-[25%] right-[10%]">
          <TableOfContents />
        </aside>

        <div className="w-full prose">
          <MDXRemote
            source={content}
            components={components}
            options={{
              mdxOptions: {
                rehypePlugins: [rehypePrism],
              },
            }}
          />
        </div>
      </div>
    </div>
  </div>
);
```

Finally, we render the blog post. We display:

1. The post metadata (date and reading time).
2. A table of contents in an aside.
3. The MDX content using `MDXRemote`, with our custom components and the `rehypePrism` plugin for syntax highlighting.

## Conclusion

This setup allows you to create a dynamic blog using MDX files in Next.js. By placing your MDX files in the `content/posts` directory, you can easily manage your blog content separate from your code. The `[slug].tsx` page component handles the rendering of each blog post, providing a clean and extensible solution for your blog.

Remember to style your components and add any additional features you might need, such as pagination or category filtering. Happy blogging!