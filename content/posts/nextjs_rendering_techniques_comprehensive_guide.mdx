---
title: "Next.js Rendering Techniques: A Complete Guide to CSR, SSR, SSG, and ISR"
description: Master Next.js rendering strategies including Client-Side Rendering (CSR), Server-Side Rendering (SSR), Static Site Generation (SSG), and Incremental Static Regeneration (ISR). Learn when to use each technique with practical examples and real-world use cases.
date: 2025-09-08
tags: [nextjs, rendering, ssr, csr, ssg, isr, performance, web-development]
---

# Next.js Rendering Techniques: A Complete Guide to CSR, SSR, SSG, and ISR

Next.js has revolutionized how we build React applications by offering multiple rendering strategies out of the box. Understanding when and how to use Client-Side Rendering (CSR), Server-Side Rendering (SSR), Static Site Generation (SSG), and Incremental Static Regeneration (ISR) is crucial for building performant, scalable web applications.

This guide will walk you through each rendering technique, explain their benefits and trade-offs, and provide practical examples to help you choose the right approach for your specific use cases.

## Understanding the Rendering Landscape

Before diving into specific techniques, let's understand what rendering means in the context of web applications and why it matters for performance, SEO, and user experience.

**Rendering** is the process of converting your React components and data into HTML that browsers can display. Where and when this happens significantly impacts:

<div style={{background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', padding: '20px', borderRadius: '12px', color: 'white', margin: '20px 0'}}>
  <h4 style={{color: 'white', marginTop: 0}}>üöÄ Why Rendering Strategy Matters</h4>
  <ul style={{marginBottom: 0}}>
    <li><strong>Performance:</strong> How fast your pages load and become interactive</li>
    <li><strong>SEO:</strong> How well search engines can crawl and index your content</li>
    <li><strong>User Experience:</strong> How quickly users see meaningful content</li>
    <li><strong>Server Load:</strong> How much computational work your servers need to handle</li>
    <li><strong>Caching:</strong> How effectively you can cache and serve content</li>
  </ul>
</div>

## Client-Side Rendering (CSR)

Client-Side Rendering is the traditional approach where JavaScript runs in the browser to render your React components after the initial HTML is loaded.

### How CSR Works

1. Browser requests a page from your Next.js application
2. Server sends a minimal HTML document with JavaScript bundles
3. Browser downloads and executes JavaScript
4. JavaScript fetches data from APIs
5. React components render in the browser
6. Page becomes interactive

### When to Use CSR

<div style={{background: 'linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%)', padding: '18px', borderRadius: '10px', borderLeft: '4px solid #fdcb6e', margin: '16px 0'}}>
  <h4 style={{color: '#2d3436', marginTop: 0}}>üí° Perfect for CSR:</h4>
  <ul style={{color: '#2d3436', marginBottom: 0}}>
    <li><strong>Dashboard applications</strong> with frequent user interactions</li>
    <li><strong>Admin panels</strong> that require authentication</li>
    <li><strong>Real-time applications</strong> with live data updates</li>
    <li><strong>Interactive tools</strong> and calculators</li>
    <li><strong>Private content</strong> that doesn't need SEO</li>
  </ul>
</div>

### CSR Implementation Examples

#### Basic CSR with useEffect

```jsx
// pages/dashboard.js
import { useState, useEffect } from 'react';

export default function Dashboard() {
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUserData() {
      try {
        const response = await fetch('/api/user/profile');
        const data = await response.json();
        setUserData(data);
      } catch (error) {
        console.error('Failed to fetch user data:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchUserData();
  }, []);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  return (
    <div className="dashboard">
      <h1>Welcome back, {userData?.name}!</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <DashboardCard title="Orders" value={userData?.orderCount} />
        <DashboardCard title="Revenue" value={`$${userData?.revenue}`} />
        <DashboardCard title="Products" value={userData?.productCount} />
      </div>
    </div>
  );
}
```

#### Advanced CSR with SWR for Data Fetching

```jsx
// pages/admin/analytics.js
import useSWR from 'swr';
import { useState } from 'react';

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function Analytics() {
  const [dateRange, setDateRange] = useState('7d');
  
  const { data: analyticsData, error, mutate } = useSWR(
    `/api/analytics?range=${dateRange}`,
    fetcher,
    {
      refreshInterval: 30000, // Refresh every 30 seconds
      revalidateOnFocus: true
    }
  );

  const handleDateRangeChange = (newRange) => {
    setDateRange(newRange);
    mutate(); // Trigger revalidation
  };

  if (error) return <div>Failed to load analytics data</div>;
  if (!analyticsData) return <AnalyticsSkeleton />;

  return (
    <div className="analytics-dashboard">
      <div className="flex justify-between items-center mb-8">
        <h1>Analytics Dashboard</h1>
        <DateRangePicker 
          value={dateRange} 
          onChange={handleDateRangeChange}
        />
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <RealtimeChart data={analyticsData.realtimeData} />
        <ConversionFunnel data={analyticsData.conversionData} />
        <UserEngagement data={analyticsData.engagementData} />
        <RevenueMetrics data={analyticsData.revenueData} />
      </div>
    </div>
  );
}
```

### CSR Benefits and Drawbacks

<div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', margin: '20px 0'}}>
  <div style={{background: 'linear-gradient(135deg, #00b894 0%, #00cec9 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚úÖ Benefits</h4>
    <ul style={{marginBottom: 0}}>
      <li>Fast navigation between pages after initial load</li>
      <li>Rich, interactive user experiences</li>
      <li>Reduced server load</li>
      <li>Great for authenticated, private content</li>
    </ul>
  </div>
  <div style={{background: 'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚ùå Drawbacks</h4>
    <ul style={{marginBottom: 0}}>
      <li>Slower initial page load</li>
      <li>Poor SEO performance</li>
      <li>JavaScript dependency for content visibility</li>
      <li>Potential layout shifts during loading</li>
    </ul>
  </div>
</div>

## Server-Side Rendering (SSR)

Server-Side Rendering generates HTML on the server for each request, ensuring users receive fully rendered pages immediately.

### How SSR Works

1. User requests a page
2. Next.js server runs your page component
3. Server fetches any required data
4. Server renders React components to HTML
5. Complete HTML is sent to the browser
6. Browser displays content immediately
7. JavaScript hydrates the page for interactivity

### When to Use SSR

<div style={{background: 'linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%)', padding: '18px', borderRadius: '10px', borderLeft: '4px solid #5f3dc4', margin: '16px 0', color: 'white'}}>
  <h4 style={{color: 'white', marginTop: 0}}>üéØ Perfect for SSR:</h4>
  <ul style={{marginBottom: 0}}>
    <li><strong>E-commerce product pages</strong> that need fresh pricing</li>
    <li><strong>News websites</strong> with frequently updated content</li>
    <li><strong>User-specific content</strong> that changes per request</li>
    <li><strong>Pages requiring authentication</strong> with SEO needs</li>
    <li><strong>Real-time data</strong> that must be current</li>
  </ul>
</div>

### SSR Implementation Examples

#### Basic SSR with getServerSideProps

```jsx
// pages/product/[id].js
import { GetServerSideProps } from 'next';

export default function ProductPage({ product, relatedProducts, userReviews }) {
  return (
    <div className="product-page">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <ProductImageGallery images={product.images} />
        <div className="product-details">
          <h1 className="text-3xl font-bold mb-4">{product.name}</h1>
          <div className="flex items-center gap-4 mb-4">
            <span className="text-2xl font-semibold text-green-600">
              ${product.price}
            </span>
            {product.originalPrice && (
              <span className="text-lg line-through text-gray-500">
                ${product.originalPrice}
              </span>
            )}
          </div>
          
          <div className="flex items-center gap-2 mb-6">
            <StarRating rating={product.averageRating} />
            <span className="text-sm text-gray-600">
              ({userReviews.length} reviews)
            </span>
          </div>
          
          <div className="mb-6">
            <h3 className="font-semibold mb-2">Description</h3>
            <p className="text-gray-700">{product.description}</p>
          </div>
          
          <AddToCartButton productId={product.id} />
        </div>
      </div>
      
      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-6">Customer Reviews</h2>
        <ReviewsList reviews={userReviews} />
      </div>
      
      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-6">Related Products</h2>
        <ProductGrid products={relatedProducts} />
      </div>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { id } = context.params!;
  const { req } = context;
  
  try {
    // Get user session for personalized content
    const session = await getSession(req);
    
    // Fetch product data
    const [productRes, reviewsRes] = await Promise.all([
      fetch(`${process.env.API_URL}/products/${id}`),
      fetch(`${process.env.API_URL}/products/${id}/reviews`)
    ]);
    
    if (!productRes.ok) {
      return {
        notFound: true,
      };
    }
    
    const product = await productRes.json();
    const userReviews = await reviewsRes.json();
    
    // Fetch related products based on category
    const relatedRes = await fetch(
      `${process.env.API_URL}/products?category=${product.category}&limit=4&exclude=${id}`
    );
    const relatedProducts = await relatedRes.json();
    
    // Apply user-specific pricing if logged in
    if (session?.user) {
      const userPricing = await getUserPricing(session.user.id, product.id);
      product.price = userPricing.price || product.price;
    }
    
    return {
      props: {
        product,
        relatedProducts: relatedProducts.data || [],
        userReviews: userReviews.data || []
      },
    };
  } catch (error) {
    console.error('Error fetching product data:', error);
    return {
      notFound: true,
    };
  }
};
```

#### Advanced SSR with User Authentication

```jsx
// pages/profile/orders.js
import { GetServerSideProps } from 'next';
import { getSession } from 'next-auth/react';

export default function OrdersPage({ orders, user }) {
  return (
    <div className="max-w-4xl mx-auto py-8 px-4">
      <h1 className="text-3xl font-bold mb-8">My Orders</h1>
      
      <div className="space-y-6">
        {orders.map((order) => (
          <div key={order.id} className="border rounded-lg p-6 shadow-sm">
            <div className="flex justify-between items-start mb-4">
              <div>
                <h3 className="font-semibold text-lg">Order #{order.id}</h3>
                <p className="text-gray-600">{formatDate(order.createdAt)}</p>
              </div>
              <OrderStatus status={order.status} />
            </div>
            
            <div className="space-y-3">
              {order.items.map((item) => (
                <div key={item.id} className="flex items-center gap-4">
                  <img 
                    src={item.product.thumbnail} 
                    alt={item.product.name}
                    className="w-16 h-16 object-cover rounded"
                  />
                  <div className="flex-1">
                    <h4 className="font-medium">{item.product.name}</h4>
                    <p className="text-gray-600">Quantity: {item.quantity}</p>
                  </div>
                  <span className="font-semibold">
                    ${(item.price * item.quantity).toFixed(2)}
                  </span>
                </div>
              ))}
            </div>
            
            <div className="mt-4 pt-4 border-t flex justify-between items-center">
              <span className="font-semibold">
                Total: ${order.total.toFixed(2)}
              </span>
              <div className="space-x-2">
                <TrackOrderButton orderId={order.id} />
                {order.status === 'delivered' && (
                  <ReviewOrderButton orderId={order.id} />
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const session = await getSession(context);
  
  // Redirect to login if not authenticated
  if (!session) {
    return {
      redirect: {
        destination: '/login?callbackUrl=' + encodeURIComponent(context.resolvedUrl),
        permanent: false,
      },
    };
  }
  
  try {
    // Fetch user's orders
    const ordersRes = await fetch(
      `${process.env.API_URL}/users/${session.user.id}/orders`,
      {
        headers: {
          'Authorization': `Bearer ${session.accessToken}`,
        },
      }
    );
    
    if (!ordersRes.ok) {
      throw new Error('Failed to fetch orders');
    }
    
    const orders = await ordersRes.json();
    
    return {
      props: {
        orders: orders.data || [],
        user: session.user,
      },
    };
  } catch (error) {
    console.error('Error fetching orders:', error);
    return {
      props: {
        orders: [],
        user: session.user,
      },
    };
  }
};
```

### SSR Benefits and Drawbacks

<div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', margin: '20px 0'}}>
  <div style={{background: 'linear-gradient(135deg, #00b894 0%, #00cec9 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚úÖ Benefits</h4>
    <ul style={{marginBottom: 0}}>
      <li>Immediate content visibility</li>
      <li>Excellent SEO performance</li>
      <li>Always up-to-date content</li>
      <li>Good for personalized, dynamic content</li>
    </ul>
  </div>
  <div style={{background: 'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚ùå Drawbacks</h4>
    <ul style={{marginBottom: 0}}>
      <li>Higher server load</li>
      <li>Slower navigation between pages</li>
      <li>Increased hosting costs</li>
      <li>Complex caching strategies needed</li>
    </ul>
  </div>
</div>

## Static Site Generation (SSG)

Static Site Generation pre-builds pages at build time, creating static HTML files that can be served instantly from a CDN.

### How SSG Works

1. During build process, Next.js runs your page components
2. Any required data is fetched using getStaticProps
3. React components are rendered to static HTML
4. HTML files are generated and stored
5. When users request pages, pre-built HTML is served immediately
6. JavaScript hydrates the page for interactivity

### When to Use SSG

<div style={{background: 'linear-gradient(135deg, #55a3ff 0%, #003d82 100%)', padding: '18px', borderRadius: '10px', borderLeft: '4px solid #0984e3', margin: '16px 0', color: 'white'}}>
  <h4 style={{color: 'white', marginTop: 0}}>‚ö° Perfect for SSG:</h4>
  <ul style={{marginBottom: 0}}>
    <li><strong>Blog posts</strong> and articles</li>
    <li><strong>Documentation sites</strong></li>
    <li><strong>Marketing pages</strong> and landing pages</li>
    <li><strong>Portfolio websites</strong></li>
    <li><strong>Product catalogs</strong> with infrequent updates</li>
    <li><strong>Company websites</strong> with mostly static content</li>
  </ul>
</div>

### SSG Implementation Examples

#### Basic SSG for Blog Posts

```jsx
// pages/blog/[slug].js
import { GetStaticProps, GetStaticPaths } from 'next';
import { MDXRemote } from 'next-mdx-remote';
import { serialize } from 'next-mdx-remote/serialize';
import { getAllPosts, getPostBySlug } from '../../lib/blog';

export default function BlogPost({ post, mdxSource, relatedPosts }) {
  return (
    <article className="max-w-4xl mx-auto py-12 px-4">
      <header className="mb-12">
        <h1 className="text-4xl font-bold mb-4">{post.title}</h1>
        <div className="flex items-center gap-4 text-gray-600 mb-6">
          <time>{formatDate(post.date)}</time>
          <span>‚Ä¢</span>
          <span>{post.readingTime} min read</span>
          <span>‚Ä¢</span>
          <AuthorInfo author={post.author} />
        </div>
        
        <div className="flex flex-wrap gap-2 mb-8">
          {post.tags.map((tag) => (
            <span
              key={tag}
              className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
            >
              {tag}
            </span>
          ))}
        </div>
        
        {post.featuredImage && (
          <img
            src={post.featuredImage}
            alt={post.title}
            className="w-full h-64 object-cover rounded-lg mb-8"
          />
        )}
      </header>
      
      <div className="prose prose-lg max-w-none">
        <MDXRemote {...mdxSource} components={mdxComponents} />
      </div>
      
      <footer className="mt-16 pt-8 border-t">
        <div className="mb-8">
          <h3 className="text-xl font-semibold mb-4">About the Author</h3>
          <AuthorBio author={post.author} />
        </div>
        
        <div className="mb-8">
          <h3 className="text-xl font-semibold mb-4">Related Articles</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {relatedPosts.map((relatedPost) => (
              <BlogPostCard key={relatedPost.slug} post={relatedPost} />
            ))}
          </div>
        </div>
        
        <ShareButtons 
          url={`https://yourblog.com/blog/${post.slug}`}
          title={post.title}
        />
      </footer>
    </article>
  );
}

export const getStaticProps: GetStaticProps = async ({ params }) => {
  const post = await getPostBySlug(params!.slug as string);
  
  if (!post) {
    return {
      notFound: true,
    };
  }
  
  // Serialize MDX content
  const mdxSource = await serialize(post.content, {
    parseFrontmatter: true,
    mdxOptions: {
      remarkPlugins: [
        // Add remark plugins for better markdown processing
      ],
      rehypePlugins: [
        // Add rehype plugins for HTML processing
      ],
    },
  });
  
  // Get related posts
  const allPosts = await getAllPosts();
  const relatedPosts = allPosts
    .filter(p => 
      p.slug !== post.slug && 
      p.tags.some(tag => post.tags.includes(tag))
    )
    .slice(0, 4);
  
  return {
    props: {
      post,
      mdxSource,
      relatedPosts,
    },
    // Regenerate the page at most once every hour
    revalidate: 3600,
  };
};

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await getAllPosts();
  
  const paths = posts.map((post) => ({
    params: { slug: post.slug },
  }));
  
  return {
    paths,
    // Generate other pages on-demand
    fallback: 'blocking',
  };
};
```

#### Advanced SSG for E-commerce Categories

```jsx
// pages/category/[slug].js
import { GetStaticProps, GetStaticPaths } from 'next';

export default function CategoryPage({ 
  category, 
  products, 
  filters, 
  totalPages,
  seoData 
}) {
  const [filteredProducts, setFilteredProducts] = useState(products);
  const [currentFilters, setCurrentFilters] = useState({});
  
  return (
    <>
      <Head>
        <title>{seoData.title}</title>
        <meta name="description" content={seoData.description} />
        <script 
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify(seoData.structuredData)
          }}
        />
      </Head>
      
      <div className="category-page">
        <header className="bg-gradient-to-r from-blue-600 to-purple-600 text-white py-16">
          <div className="container mx-auto px-4">
            <h1 className="text-4xl font-bold mb-4">{category.name}</h1>
            <p className="text-xl opacity-90">{category.description}</p>
            <div className="mt-6">
              <span className="text-sm opacity-75">
                {products.length} products available
              </span>
            </div>
          </div>
        </header>
        
        <div className="container mx-auto px-4 py-8">
          <div className="flex flex-col lg:flex-row gap-8">
            <aside className="lg:w-64">
              <ProductFilters 
                filters={filters}
                onFilterChange={setCurrentFilters}
              />
            </aside>
            
            <main className="flex-1">
              <div className="flex justify-between items-center mb-6">
                <h2 className="text-2xl font-semibold">Products</h2>
                <ProductSorting />
              </div>
              
              <ProductGrid products={filteredProducts} />
              
              {totalPages > 1 && (
                <Pagination 
                  currentPage={1} 
                  totalPages={totalPages}
                  baseUrl={`/category/${category.slug}`}
                />
              )}
            </main>
          </div>
        </div>
      </div>
    </>
  );
}

export const getStaticProps: GetStaticProps = async ({ params }) => {
  const { slug } = params!;
  
  try {
    // Fetch category data
    const categoryRes = await fetch(`${process.env.API_URL}/categories/${slug}`);
    if (!categoryRes.ok) {
      return { notFound: true };
    }
    const category = await categoryRes.json();
    
    // Fetch products for this category
    const [productsRes, filtersRes] = await Promise.all([
      fetch(`${process.env.API_URL}/products?category=${slug}&limit=24`),
      fetch(`${process.env.API_URL}/categories/${slug}/filters`)
    ]);
    
    const [productsData, filters] = await Promise.all([
      productsRes.json(),
      filtersRes.json()
    ]);
    
    // Generate SEO data
    const seoData = {
      title: `${category.name} - Shop Quality Products | Your Store`,
      description: `Discover our ${category.name.toLowerCase()} collection. ${category.description}`,
      structuredData: {
        "@context": "https://schema.org",
        "@type": "CollectionPage",
        "name": category.name,
        "description": category.description,
        "url": `https://yourstore.com/category/${slug}`,
        "mainEntity": {
          "@type": "ItemList",
          "numberOfItems": productsData.total,
          "itemListElement": productsData.products.map((product, index) => ({
            "@type": "ListItem",
            "position": index + 1,
            "item": {
              "@type": "Product",
              "name": product.name,
              "url": `https://yourstore.com/product/${product.slug}`,
              "image": product.thumbnail,
              "offers": {
                "@type": "Offer",
                "price": product.price,
                "priceCurrency": "USD"
              }
            }
          }))
        }
      }
    };
    
    return {
      props: {
        category,
        products: productsData.products || [],
        filters: filters || [],
        totalPages: Math.ceil(productsData.total / 24),
        seoData
      },
      // Revalidate every day
      revalidate: 86400,
    };
  } catch (error) {
    console.error('Error fetching category data:', error);
    return { notFound: true };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  try {
    // Fetch all categories
    const categoriesRes = await fetch(`${process.env.API_URL}/categories`);
    const categories = await categoriesRes.json();
    
    // Generate paths for the most popular categories
    const paths = categories
      .filter(category => category.productCount > 0)
      .map((category) => ({
        params: { slug: category.slug }
      }));
    
    return {
      paths,
      // Generate other category pages on-demand
      fallback: 'blocking',
    };
  } catch (error) {
    return {
      paths: [],
      fallback: 'blocking',
    };
  }
};
```

### SSG Benefits and Drawbacks

<div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', margin: '20px 0'}}>
  <div style={{background: 'linear-gradient(135deg, #00b894 0%, #00cec9 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚úÖ Benefits</h4>
    <ul style={{marginBottom: 0}}>
      <li>Lightning-fast page loads</li>
      <li>Excellent SEO performance</li>
      <li>Low hosting costs</li>
      <li>Automatic CDN distribution</li>
      <li>High scalability</li>
    </ul>
  </div>
  <div style={{background: 'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚ùå Drawbacks</h4>
    <ul style={{marginBottom: 0}}>
      <li>Build time increases with more pages</li>
      <li>Content updates require rebuilds</li>
      <li>Not suitable for frequently changing data</li>
      <li>Complex for user-specific content</li>
    </ul>
  </div>
</div>

## Incremental Static Regeneration (ISR)

ISR combines the benefits of SSG with the ability to update content without full rebuilds. It allows you to create or update static pages after deployment.

### How ISR Works

1. Pages are initially built statically like SSG
2. When a user requests a page, static version is served instantly
3. If the page is stale (past revalidate time), Next.js triggers regeneration
4. Updated page is generated in the background
5. New version replaces the old static file
6. Subsequent requests get the updated version

### When to Use ISR

<div style={{background: 'linear-gradient(135deg, #ff7675 0%, #d63031 100%)', padding: '18px', borderRadius: '10px', borderLeft: '4px solid #e17055', margin: '16px 0', color: 'white'}}>
  <h4 style={{color: 'white', marginTop: 0}}>üîÑ Perfect for ISR:</h4>
  <ul style={{marginBottom: 0}}>
    <li><strong>News websites</strong> with regular content updates</li>
    <li><strong>E-commerce sites</strong> with changing inventory</li>
    <li><strong>Documentation</strong> that needs periodic updates</li>
    <li><strong>CMS-driven sites</strong> with editorial workflows</li>
    <li><strong>API-dependent content</strong> that changes moderately</li>
  </ul>
</div>

### ISR Implementation Examples

#### News Website with Automatic Updates

```jsx
// pages/news/[slug].js
import { GetStaticProps, GetStaticPaths } from 'next';

export default function NewsArticle({ article, relatedArticles }) {
  return (
    <article className="max-w-4xl mx-auto py-8 px-4">
      <header className="mb-8">
        <div className="flex items-center gap-2 text-sm text-gray-600 mb-2">
          <span className="bg-red-100 text-red-800 px-2 py-1 rounded">
            {article.category}
          </span>
          <span>‚Ä¢</span>
          <time>{formatDate(article.publishedAt)}</time>
          {article.updatedAt !== article.publishedAt && (
            <>
              <span>‚Ä¢</span>
              <span>Updated {formatDate(article.updatedAt)}</span>
            </>
          )}
        </div>
        
        <h1 className="text-4xl font-bold mb-4">{article.title}</h1>
        <p className="text-xl text-gray-700 mb-6">{article.summary}</p>
        
        <div className="flex items-center gap-4 mb-6">
          <AuthorAvatar author={article.author} />
          <div>
            <p className="font-semibold">{article.author.name}</p>
            <p className="text-sm text-gray-600">{article.author.title}</p>
          </div>
        </div>
        
        {article.featuredImage && (
          <img
            src={article.featuredImage.url}
            alt={article.featuredImage.alt}
            className="w-full h-96 object-cover rounded-lg mb-8"
          />
        )}
      </header>
      
      <div 
        className="prose prose-lg max-w-none mb-12"
        dangerouslySetInnerHTML={{ __html: article.content }}
      />
      
      <footer>
        <div className="bg-gray-50 p-6 rounded-lg mb-8">
          <h3 className="font-semibold mb-2">Breaking News Updates</h3>
          <p className="text-sm text-gray-600 mb-4">
            This story is developing. Last updated: {formatDateTime(article.updatedAt)}
          </p>
          {article.updates && article.updates.length > 0 && (
            <div className="space-y-2">
              {article.updates.slice(0, 3).map((update, index) => (
                <div key={index} className="text-sm">
                  <span className="font-medium">{formatTime(update.timestamp)}: </span>
                  {update.content}
                </div>
              ))}
            </div>
          )}
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <h3 className="font-semibold mb-4">Related Stories</h3>
            <div className="space-y-3">
              {relatedArticles.map((related) => (
                <RelatedArticleCard key={related.id} article={related} />
              ))}
            </div>
          </div>
          
          <div>
            <h3 className="font-semibold mb-4">Share This Story</h3>
            <SocialShareButtons 
              url={`https://yournews.com/news/${article.slug}`}
              title={article.title}
            />
          </div>
        </div>
      </footer>
    </article>
  );
}

export const getStaticProps: GetStaticProps = async ({ params }) => {
  try {
    const { slug } = params!;
    
    // Fetch article data
    const articleRes = await fetch(`${process.env.API_URL}/articles/${slug}`);
    if (!articleRes.ok) {
      return { notFound: true };
    }
    
    const article = await articleRes.json();
    
    // Fetch related articles
    const relatedRes = await fetch(
      `${process.env.API_URL}/articles?category=${article.category}&exclude=${article.id}&limit=5`
    );
    const relatedData = await relatedRes.json();
    
    return {
      props: {
        article,
        relatedArticles: relatedData.articles || [],
      },
      // Revalidate every 5 minutes for breaking news
      revalidate: 300,
    };
  } catch (error) {
    console.error('Error fetching article:', error);
    return { notFound: true };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  try {
    // Pre-build paths for recent articles only
    const recentRes = await fetch(
      `${process.env.API_URL}/articles?limit=100&sort=publishedAt:desc`
    );
    const recentData = await recentRes.json();
    
    const paths = recentData.articles.map((article) => ({
      params: { slug: article.slug }
    }));
    
    return {
      paths,
      // Generate older articles on-demand
      fallback: 'blocking',
    };
  } catch (error) {
    return {
      paths: [],
      fallback: 'blocking',
    };
  }
};
```

#### E-commerce with Dynamic Inventory

```jsx
// pages/products/[slug].js
import { GetStaticProps, GetStaticPaths } from 'next';

export default function ProductPage({ 
  product, 
  inventory, 
  reviews, 
  recommendations 
}) {
  const isInStock = inventory.quantity > 0;
  const lowStock = inventory.quantity < 10 && inventory.quantity > 0;
  
  return (
    <div className="product-page max-w-6xl mx-auto py-8 px-4">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-12">
        <ProductImageGallery images={product.images} />
        
        <div className="product-info">
          <h1 className="text-3xl font-bold mb-4">{product.name}</h1>
          
          <div className="flex items-center gap-4 mb-6">
            <div className="flex items-center gap-2">
              <StarRating rating={product.averageRating} />
              <span className="text-sm text-gray-600">
                ({reviews.total} reviews)
              </span>
            </div>
          </div>
          
          <div className="pricing mb-6">
            <div className="flex items-center gap-3">
              <span className="text-3xl font-bold text-green-600">
                ${product.price.toFixed(2)}
              </span>
              {product.originalPrice && product.originalPrice > product.price && (
                <span className="text-xl line-through text-gray-500">
                  ${product.originalPrice.toFixed(2)}
                </span>
              )}
            </div>
          </div>
          
          <div className="stock-info mb-6">
            {isInStock ? (
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                <span className="text-green-700 font-medium">In Stock</span>
                {lowStock && (
                  <span className="text-orange-600 text-sm">
                    (Only {inventory.quantity} left!)
                  </span>
                )}
              </div>
            ) : (
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-red-500 rounded-full"></div>
                <span className="text-red-700 font-medium">Out of Stock</span>
              </div>
            )}
          </div>
          
          <div className="purchase-options mb-8">
            {isInStock ? (
              <div className="space-y-4">
                <QuantitySelector max={Math.min(inventory.quantity, 10)} />
                <AddToCartButton 
                  productId={product.id} 
                  disabled={!isInStock}
                />
                <WishlistButton productId={product.id} />
              </div>
            ) : (
              <div className="space-y-4">
                <NotifyWhenAvailableButton productId={product.id} />
                <div className="text-sm text-gray-600">
                  Expected back in stock: {inventory.expectedRestockDate}
                </div>
              </div>
            )}
          </div>
          
          <ProductDetails product={product} />
        </div>
      </div>
      
      <div className="mt-16">
        <ProductTabs 
          description={product.description}
          specifications={product.specifications}
          reviews={reviews}
        />
      </div>
      
      {recommendations.length > 0 && (
        <div className="mt-16">
          <h2 className="text-2xl font-bold mb-8">Recommended Products</h2>
          <ProductSlider products={recommendations} />
        </div>
      )}
    </div>
  );
}

export const getStaticProps: GetStaticProps = async ({ params }) => {
  try {
    const { slug } = params!;
    
    // Fetch all data in parallel
    const [productRes, inventoryRes, reviewsRes] = await Promise.all([
      fetch(`${process.env.API_URL}/products/${slug}`),
      fetch(`${process.env.API_URL}/products/${slug}/inventory`),
      fetch(`${process.env.API_URL}/products/${slug}/reviews?limit=10`)
    ]);
    
    if (!productRes.ok) {
      return { notFound: true };
    }
    
    const [product, inventory, reviewsData] = await Promise.all([
      productRes.json(),
      inventoryRes.json(),
      reviewsRes.json()
    ]);
    
    // Fetch recommendations based on product category
    const recommendationsRes = await fetch(
      `${process.env.API_URL}/products/recommendations?productId=${product.id}&limit=8`
    );
    const recommendations = await recommendationsRes.json();
    
    return {
      props: {
        product,
        inventory,
        reviews: reviewsData,
        recommendations: recommendations.products || [],
      },
      // Revalidate every 10 minutes to keep inventory fresh
      revalidate: 600,
    };
  } catch (error) {
    console.error('Error fetching product data:', error);
    return { notFound: true };
  }
};

export const getStaticPaths: GetStaticPaths = async () => {
  try {
    // Pre-build paths for popular/featured products only
    const featuredRes = await fetch(
      `${process.env.API_URL}/products?featured=true&limit=200`
    );
    const featuredData = await featuredRes.json();
    
    const paths = featuredData.products.map((product) => ({
      params: { slug: product.slug }
    }));
    
    return {
      paths,
      // Generate other product pages on-demand
      fallback: 'blocking',
    };
  } catch (error) {
    return {
      paths: [],
      fallback: 'blocking',
    };
  }
};
```

### ISR Benefits and Drawbacks

<div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', margin: '20px 0'}}>
  <div style={{background: 'linear-gradient(135deg, #00b894 0%, #00cec9 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚úÖ Benefits</h4>
    <ul style={{marginBottom: 0}}>
      <li>Fast initial loads like SSG</li>
      <li>Content updates without full rebuilds</li>
      <li>Good balance of performance and freshness</li>
      <li>Automatic background regeneration</li>
      <li>Handles traffic spikes well</li>
    </ul>
  </div>
  <div style={{background: 'linear-gradient(135deg, #fd79a8 0%, #e84393 100%)', padding: '20px', borderRadius: '12px', color: 'white'}}>
    <h4 style={{color: 'white', marginTop: 0}}>‚ùå Drawbacks</h4>
    <ul style={{marginBottom: 0}}>
      <li>Complex caching behavior to understand</li>
      <li>First visitor after revalidation sees old content</li>
      <li>Not suitable for real-time data</li>
      <li>Can increase server costs</li>
    </ul>
  </div>
</div>

## Choosing the Right Rendering Technique

### Real-World Application Examples

#### 1. E-commerce Website Architecture

```
Homepage ‚Üí SSG (marketing content, featured products)
Product Listing ‚Üí ISR (inventory changes, new products)
Product Details ‚Üí ISR (stock levels, reviews)
User Dashboard ‚Üí CSR (personalized, private)
Checkout ‚Üí SSR (real-time pricing, inventory)
Order Confirmation ‚Üí SSR (user-specific data)
```

#### 2. News Website Architecture

```
Homepage ‚Üí ISR (breaking news updates)
Article Pages ‚Üí ISR (comments, view counts)
Author Pages ‚Üí SSG (rarely change)
Category Pages ‚Üí ISR (new articles)
User Profile ‚Üí CSR (personalized content)
```

#### 3. SaaS Application Architecture

```
Marketing Site ‚Üí SSG (static content)
Documentation ‚Üí SSG (version-controlled content)
Login/Signup ‚Üí SSR (SEO + security)
Dashboard ‚Üí CSR (highly interactive)
Settings ‚Üí CSR (user-specific)
```

## Performance Optimization Strategies

### Optimizing CSR Applications

```jsx
// utils/performance.js
import { lazy, Suspense } from 'react';

// Code splitting for better performance
const Dashboard = lazy(() => import('../components/Dashboard'));
const Analytics = lazy(() => import('../components/Analytics'));

export default function App() {
  return (
    <div>
      <Suspense fallback={<DashboardSkeleton />}>
        <Dashboard />
      </Suspense>
      
      <Suspense fallback={<AnalyticsSkeleton />}>
        <Analytics />
      </Suspense>
    </div>
  );
}

// Custom hook for optimized data fetching
export function useOptimizedFetch(url, options = {}) {
  return useSWR(url, fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    refreshInterval: options.refreshInterval || 0,
    dedupingInterval: options.dedupingInterval || 2000,
  });
}
```

### Optimizing SSR Performance

```jsx
// next.config.js
module.exports = {
  // Enable SWC for faster builds
  swcMinify: true,
  
  // Optimize server-side rendering
  experimental: {
    serverComponentsExternalPackages: ['expensive-package'],
  },
  
  // Configure caching headers
  async headers() {
    return [
      {
        source: '/api/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, s-maxage=10, stale-while-revalidate=59',
          },
        ],
      },
    ];
  },
};

// lib/cache.js
import NodeCache from 'node-cache';
const cache = new NodeCache({ stdTTL: 300 }); // 5 minutes

export async function getCachedData(key, fetchFunction) {
  const cached = cache.get(key);
  if (cached) return cached;
  
  const data = await fetchFunction();
  cache.set(key, data);
  return data;
}
```

### ISR Cache Management

```jsx
// pages/api/revalidate.js
export default async function handler(req, res) {
  // Check for secret to confirm this is a valid request
  if (req.query.secret !== process.env.REVALIDATE_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }
  
  try {
    const { path, paths } = req.query;
    
    if (paths) {
      // Revalidate multiple paths
      const pathArray = Array.isArray(paths) ? paths : [paths];
      await Promise.all(
        pathArray.map(p => res.revalidate(p))
      );
    } else if (path) {
      // Revalidate single path
      await res.revalidate(path);
    }
    
    return res.json({ revalidated: true });
  } catch (err) {
    return res.status(500).send('Error revalidating');
  }
}
```

## Conclusion

Understanding and effectively implementing Next.js rendering techniques is crucial for building high-performance web applications. Each approach has its strengths and ideal use cases:

<div style={{background: 'linear-gradient(135deg, #74b9ff 0%, #0984e3 100%)', padding: '24px', borderRadius: '15px', margin: '24px 0', color: 'white'}}>
  <h4 style={{color: 'white', marginTop: 0}}>üéØ Quick Reference Guide</h4>
  <ul style={{marginBottom: '16px'}}>
    <li><strong>CSR</strong> excels for highly interactive, personalized applications</li>
    <li><strong>SSR</strong> provides the best SEO and initial load performance for dynamic content</li>
    <li><strong>SSG</strong> offers unbeatable speed and cost-effectiveness for static content</li>
    <li><strong>ISR</strong> bridges the gap between static and dynamic with smart regeneration</li>
  </ul>
  
  <h4 style={{color: 'white', marginTop: '20px', marginBottom: '12px'}}>üöÄ Path to Success:</h4>
  <ol style={{marginBottom: 0}}>
    <li><strong>Analyzing your content patterns</strong> and user needs</li>
    <li><strong>Choosing the right technique</strong> for each page or section</li>
    <li><strong>Optimizing performance</strong> within your chosen approach</li>
    <li><strong>Monitoring real-world metrics</strong> to validate your decisions</li>
    <li><strong>Iterating and improving</strong> based on user feedback and data</li>
  </ol>
</div>

Remember that you're not limited to one technique per application. Next.js allows you to mix and match rendering strategies, enabling you to optimize each page for its specific requirements while maintaining a cohesive user experience.

Start by implementing the basics with the examples provided, then gradually incorporate more advanced optimizations as your application grows and your requirements become clearer.